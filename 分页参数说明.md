# 分页逻辑参数说明

## 概述

本文档详细说明了Google Photos API分页逻辑所需的参数，以及这些参数在protobuf消息中的具体位置。

## 一、分页请求参数

### 1.1 请求参数列表

分页逻辑需要以下三个核心参数：

| 参数名 | 类型 | 必需 | 说明 |
|--------|------|------|------|
| `pageToken` | string | 否 | 页面令牌，用于获取下一页数据 |
| `stateToken` | string | 否 | 状态令牌，用于保持分页会话的一致性 |
| `limit` | int | 是 | 每页返回的项目数量 |

### 1.2 参数在Protobuf中的位置

#### 请求消息结构

```
请求根消息
├── field 1 (嵌套消息) - 主请求数据
│   ├── field 1.1 (嵌套消息) - 媒体元数据选项
│   ├── field 1.2 (varint) - limit (页面大小限制)
│   ├── field 1.3 (嵌套消息) - 相册和集合选项
│   ├── field 1.4 (string) - pageToken (页面令牌)
│   ├── field 1.6 (string) - stateToken (状态令牌)
│   ├── field 1.7 (varint) - 类型标识 (固定值: 2)
│   ├── field 1.11 (repeated varint) - 配置选项 [1, 2]
│   └── field 1.22 (嵌套消息) - 其他配置
└── field 2 (嵌套消息) - 附加选项
```

#### 参数字段详细说明

**1. pageToken - 字段 1.4**
- **Protobuf字段**: `field 1.4`
- **Wire类型**: 2 (length-delimited / string)
- **用途**: 指定要获取的页面位置
- **首次请求**: 为空字符串
- **后续请求**: 使用上一次响应中返回的 `nextPageToken`

**2. stateToken - 字段 1.6**
- **Protobuf字段**: `field 1.6`
- **Wire类型**: 2 (length-delimited / string)
- **用途**: 维护分页会话状态，确保数据一致性
- **首次请求**: 为空字符串
- **后续请求**: 使用上一次响应中返回的 `stateToken`

**3. limit - 字段 1.2**
- **Protobuf字段**: `field 1.2`
- **Wire类型**: 0 (varint)
- **用途**: 限制每页返回的项目数量
- **典型值**: 50

### 1.3 Go代码实现

在 `backend/api.go` 中的 `buildMediaListRequestField1` 函数：

```go
func buildMediaListRequestField1(pageToken string, stateToken string, limit int) []byte {
    var buf bytes.Buffer
    
    // field1.1 - 媒体元数据选项
    mediaMetadataFields := []int{1, 3, 4, 5, 6, 7, 15, 16, 17, 19, 20, 21, 25, 30, 31, 32, 33, 34, 36, 37, 38, 39, 40, 41}
    field1_1 := buildEmptyNestedMessage(mediaMetadataFields)
    writeProtobufField(&buf, 1, field1_1)
    
    // field1.2 - 页面大小限制 (varint)
    if limit > 0 {
        writeProtobufVarint(&buf, 2, int64(limit))
    }
    
    // field1.3 - 相册和集合选项
    albumOptions := []int{2, 3, 7, 8, 14, 16, 17, 18, 19, 20, 21, 22, 23, 27, 29, 30, 31, 32, 34, 37, 38, 39, 41}
    field1_3 := buildEmptyNestedMessage(albumOptions)
    writeProtobufField(&buf, 3, field1_3)
    
    // field1.4 - 页面令牌 (string)
    if pageToken != "" {
        writeProtobufString(&buf, 4, pageToken)
    }
    
    // field1.6 - 状态令牌 (string) - 分页所需的关键参数
    if stateToken != "" {
        writeProtobufString(&buf, 6, stateToken)
    }
    
    // field1.7 - 类型 (varint = 2)
    writeProtobufVarint(&buf, 7, 2)
    
    // field1.11 - 重复的整数 [1, 2]
    writeProtobufVarint(&buf, 11, 1)
    writeProtobufVarint(&buf, 11, 2)
    
    // field1.22 - 配置
    var field22 bytes.Buffer
    writeProtobufVarint(&field22, 1, 2)
    writeProtobufField(&buf, 22, field22.Bytes())
    
    return buf.Bytes()
}
```

## 二、分页响应参数

### 2.1 响应参数列表

API响应包含以下分页相关参数：

| 参数名 | 类型 | 说明 |
|--------|------|------|
| `items` | []MediaItem | 当前页的媒体项目列表 |
| `nextPageToken` | string | 下一页的令牌，空字符串表示已到最后一页 |
| `stateToken` | string | 状态令牌，需要在下次请求中使用 |

### 2.2 响应在Protobuf中的位置

#### 响应消息结构

```
响应根消息
└── field 1 (嵌套消息) - 主响应数据
    ├── field 1.2 (repeated 嵌套消息) - items (媒体项目数组)
    │   └── 每个媒体项目:
    │       ├── field 1 (string/嵌套) - mediaKey (媒体键)
    │       ├── field 2 (嵌套消息) - 元数据
    │       │   └── field 4 (string) - filename (文件名)
    │       ├── field 5 (varint) - mediaType (1=照片, 2=视频)
    │       └── field 4 (嵌套消息) - timestamp (时间戳)
    ├── field 1.5 (string) - stateToken (状态令牌)
    └── field 1.6 (string) - nextPageToken (下一页令牌)
```

#### 响应字段详细说明

**1. items - 字段 1.2 (repeated)**
- **Protobuf字段**: `field 1.2` (repeated)
- **Wire类型**: 2 (length-delimited / nested message)
- **用途**: 包含当前页的所有媒体项目

**2. stateToken - 字段 1.5**
- **Protobuf字段**: `field 1.5`
- **Wire类型**: 2 (length-delimited / string)
- **用途**: 返回状态令牌，必须在下次请求的 `field 1.6` 中使用

**3. nextPageToken - 字段 1.6**
- **Protobuf字段**: `field 1.6`
- **Wire类型**: 2 (length-delimited / string)
- **用途**: 返回下一页令牌，用于下次请求的 `field 1.4`
- **特殊情况**: 空字符串或不存在表示已到最后一页

### 2.3 Go代码实现

在 `backend/api.go` 中的 `parseResponseField1` 函数：

```go
func parseResponseField1(data []byte, limit int) ([]MediaItem, string, string) {
    var items []MediaItem
    var nextPageToken, stateToken string
    
    offset := 0
    for offset < len(data) {
        fieldNum, wireType, newOffset := readTag(data, offset)
        if newOffset < 0 {
            break
        }
        offset = newOffset
        
        switch wireType {
        case 0: // Varint
            _, offset = readVarint(data, offset)
        case 2: // Length-delimited
            length, newOffset := readVarint(data, offset)
            if newOffset < 0 || newOffset+int(length) > len(data) {
                return items, nextPageToken, stateToken
            }
            fieldData := data[newOffset : newOffset+int(length)]
            offset = newOffset + int(length)
            
            // Field 2 包含媒体项目数组 (repeated field)
            if fieldNum == 2 {
                item := tryParseMediaItem(fieldData)
                if item != nil && item.MediaKey != "" && shouldAddItem(len(items), limit) {
                    items = append(items, *item)
                }
            }
            // Field 6 是下一页令牌
            if fieldNum == 6 {
                nextPageToken = string(fieldData)
            }
            // Field 5 是状态令牌
            if fieldNum == 5 {
                stateToken = string(fieldData)
            }
        // ... 其他处理
        }
    }
    
    return items, nextPageToken, stateToken
}
```

## 三、分页工作流程

### 3.1 首次请求 (第一页)

**请求参数:**
```
pageToken: ""          (空字符串)
stateToken: ""         (空字符串)
limit: 50              (例如)
```

**Protobuf结构:**
```
field 1:
  field 1.2: 50        (limit)
  field 1.4: ""        (pageToken - 为空或不发送)
  field 1.6: ""        (stateToken - 为空或不发送)
```

**Go代码调用:**
```go
result, err := api.GetMediaList("", "", 50)
```

**API响应:**
```json
{
  "items": [...],              // 媒体项目列表
  "nextPageToken": "ABC123",   // 下一页令牌
  "stateToken": "XYZ789"       // 状态令牌
}
```

### 3.2 后续请求 (第二页及之后)

**请求参数:**
```
pageToken: "ABC123"    (来自上一次响应的 nextPageToken)
stateToken: "XYZ789"   (来自上一次响应的 stateToken)
limit: 50
```

**Protobuf结构:**
```
field 1:
  field 1.2: 50        (limit)
  field 1.4: "ABC123"  (pageToken)
  field 1.6: "XYZ789"  (stateToken)
```

**Go代码调用:**
```go
result, err := api.GetMediaList("ABC123", "XYZ789", 50)
```

**API响应:**
```json
{
  "items": [...],              // 新的媒体项目列表
  "nextPageToken": "DEF456",   // 新的下一页令牌
  "stateToken": "XYZ789"       // 状态令牌 (可能相同或更新)
}
```

### 3.3 最后一页

**API响应:**
```json
{
  "items": [...],              // 最后一批媒体项目
  "nextPageToken": "",         // 空字符串或不存在
  "stateToken": "XYZ789"
}
```

**检测逻辑:**
```go
if result.NextPageToken == "" {
    // 已到达最后一页
}
```

## 四、关键注意事项

### 4.1 stateToken的重要性

**为什么需要stateToken:**
1. **数据一致性**: 即使库在分页过程中发生变化，state token也能确保返回一致的数据集
2. **避免重复**: 防止同一项目在不同页面中重复出现
3. **API要求**: Google Photos API在首次请求后的所有分页请求中都需要state token

**两种分页模式:**

| 模式 | 使用场景 | stateToken | Protobuf字段 |
|------|----------|------------|-------------|
| `get_library_page_init` | 首次请求 | 不需要 (空) | field 1.4 (仅pageToken) |
| `get_library_page` | 后续请求 | 必需 | field 1.4 + field 1.6 |

### 4.2 参数传递链

**CLI实现 (cli.go):**
```go
var currentStateToken string

// 首次请求
result, err := mediaBrowser.GetMediaList("", "", pageSize)
currentStateToken = result.StateToken

// 后续请求
result, err = mediaBrowser.GetMediaList(nextPageToken, currentStateToken, pageSize)
currentStateToken = result.StateToken  // 更新state token
```

**前端实现 (Gallery.vue):**
```typescript
const stateToken = ref('')

// 首次加载
const result = await backend.GetMediaList('', '', 50)
stateToken.value = result.stateToken

// 加载更多
const result = await backend.GetMediaList(nextPageToken.value, stateToken.value, 50)
stateToken.value = result.stateToken  // 更新state token
```

## 五、与Python参考实现的对比

### 5.1 Python参考实现

**首次页面请求 (`get_library_page_init`):**
```python
proto_body = {
    "1": {
        "4": page_token,  # 仅page token
        # 没有 field 6 (state token)
    }
}
```

**后续页面请求 (`get_library_page`):**
```python
proto_body = {
    "1": {
        "4": page_token,    # Page token
        "6": state_token,   # State token - 分页所需
    }
}
```

### 5.2 Go实现 (统一接口)

Go实现使用统一的接口，通过参数是否为空来区分两种模式:

```go
func (a *Api) GetMediaList(pageToken string, stateToken string, limit int) (*MediaListResult, error) {
    // 内部根据参数自动处理两种模式
    // 当 stateToken == "" 时，表现为 get_library_page_init
    // 当 stateToken != "" 时，表现为 get_library_page
}
```

## 六、参考资料

### 6.1 相关文件

| 文件 | 说明 |
|------|------|
| `backend/api.go` | API核心实现，包含protobuf构建和解析逻辑 |
| `cli.go` | CLI分页逻辑，包含state token管理 |
| `frontend/src/Gallery.vue` | 前端分页实现 |
| `分页修复总结.md` | 分页修复的历史文档 |
| `STATE_TOKEN_FIX.md` | State token修复的详细文档 |

### 6.2 Python参考实现

| 文件 | 行号 | 说明 |
|------|------|------|
| `reference/PYTHON实现/gpmc/api.py` | 704-867 | `get_library_page_init` (无state token) |
| `reference/PYTHON实现/gpmc/api.py` | 869-1036 | `get_library_page` (有state token) |
| `reference/PYTHON实现/gpmc/client.py` | 665-692 | `_process_pages_init` |
| `reference/PYTHON实现/gpmc/client.py` | 693-720 | `_process_pages` |

## 七、总结

### 分页参数快速参考表

| 参数 | Protobuf位置 (请求) | Protobuf位置 (响应) | 数据类型 | 首次请求 | 后续请求 |
|------|-------------------|-------------------|---------|---------|---------|
| pageToken | field 1.4 | field 1.6 | string | 空 | 使用响应的nextPageToken |
| stateToken | field 1.6 | field 1.5 | string | 空 | 使用响应的stateToken |
| limit | field 1.2 | - | varint | 50 | 50 |
| items | - | field 1.2 (repeated) | nested message[] | - | - |
| nextPageToken | - | field 1.6 | string | - | - |

### 关键要点

1. **三个请求参数**: pageToken (field 1.4), stateToken (field 1.6), limit (field 1.2)
2. **三个响应参数**: items (field 1.2), nextPageToken (field 1.6), stateToken (field 1.5)
3. **注意字段映射**: 响应的 field 1.5 (stateToken) → 请求的 field 1.6 (stateToken)
4. **注意字段映射**: 响应的 field 1.6 (nextPageToken) → 请求的 field 1.4 (pageToken)
5. **stateToken是必需的**: 除了首次请求外，所有分页请求都必须包含state token
